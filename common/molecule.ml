
(* !!! DO NOT OPEN BATTERIES HERE !!!, we want plain INRIA stdlib for speed *)

open Printf

module At    = Atom
module Color = Chimera_colors
module L     = List
module Mar   = Marshal
module MU    = My_utils
module V3    = Vector3

type molecule = { name  : string       ;
                  index : int          ;
                  atoms : At.atom list }

let create name index atoms =
  { name ; index ; atoms }

let dummy () =
  create "" 0 []

let to_chan counter out m =
  Mar.to_channel out m [Mar.No_sharing];
  incr counter

let from_chan counter inp =
  let mol = (Mar.from_channel inp : molecule) in
  incr counter;
  mol

(* lines ACPC doesn't need are left empty *)
let pseudo_mol2_file m =
  "@<TRIPOS>MOLECULE" ::
    m.name ::
    "" ::
    "" ::
    "" ::
    "" ::
    "@<TRIPOS>ATOM" ::
    (L.mapi At.pseudo_mol2_line m.atoms)
  @ [ "@<TRIPOS>BOND" ;
      "@<TRIPOS>SUBSTRUCTURE" ]

(* real .pl file for the given molecule;
   this format is so simple that we can completely regenerate it
   from a molecule record *)
let pl_file m =
  "BEGIN" ::
    ("MOL " ^ m.name) ::
    (L.map At.pl_line m.atoms)
  @ ["END"]

(* lines ACPC doesn't need are left empty *)
let pseudo_pqr_file m =
  "MODEL" ::
    ("COMPND " ^ m.name) ::
    "AUTHOR GENERATED BY CACPC 1.0" ::
    (L.mapi At.pseudo_pqr_line m.atoms)
  @ ["CONECT";
     "END"]

(* output all atoms of molecule 'm' in file 'fn' (for chimera)
   using color 'color' *)
let to_bild_file m color fn =
  MU.string_list_to_file fn
    (".transparency 0.5" ::
     Color.to_bild color ::
     (L.map
        (fun a -> sprintf ".sphere %s %f" (V3.to_string (At.position a)) 1.0)
        m.atoms))

let rot_bonds_to_bild_file rot_bonds fn =
  MU.string_list_to_file fn
    (Color.to_bild Color.Hot_pink ::
       (L.map
          (fun (ai, aj) ->
             sprintf ".vector %s %s"
               (V3.to_string (At.position ai))
               (V3.to_string (At.position aj))
          )
          rot_bonds))
